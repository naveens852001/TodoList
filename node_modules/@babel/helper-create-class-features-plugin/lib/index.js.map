{"version":3,"names":["_core","require","_helperFunctionName","_helperSplitExportDeclaration","_decorators","_semver","_fields","_decorators2","_misc","_features","_typescript","versionKey","createClassFeaturePlugin","name","feature","loose","manipulateOptions","api","inherits","decoratorVersion","_api$assumption","FEATURES","decorators","createDecoratorTransform","_api","assumption","setPublicClassFields","privateFieldsAsSymbols","privateFieldsAsProperties","noUninitializedPrivateFieldAccess","constantSuper","noDocumentAll","Error","privateFieldsAsSymbolsOrProperties","explicit","undefined","push","length","console","warn","join","pre","file","enableFeature","get","set","semver","lt","visitor","Class","path","_ref","shouldTransform","pathIsClassDeclaration","isClassDeclaration","assertFieldTransformed","isLoose","constructor","isDecorated","hasDecorators","node","props","elements","computedPaths","privateNames","Set","body","isClassProperty","isClassMethod","computed","isPrivate","key","id","getName","setName","isClassPrivateMethod","kind","has","buildCodeFrameError","add","isProperty","isStaticBlock","innerBinding","ref","nameFunction","scope","generateUidIdentifier","classRefForDefine","t","cloneNode","privateNamesMap","buildPrivateNamesMap","privateNamesNodes","buildPrivateNamesNodes","transformPrivateNamesUsage","keysNodes","staticNodes","instanceNodes","lastInstanceNodeReturnsThis","pureStaticNodes","classBindingNode","wrapClass","buildDecoratedClass","extractComputedKeys","buildFieldsInitNodes","superClass","injectInitialization","referenceVisitor","state","prop","static","traverse","wrappedPath","insertBefore","insertAfter","find","parent","isStatement","isDeclaration","ExportDefaultDeclaration","decl","splitExportDeclaration","type"],"sources":["../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginAPI, PluginObject, NodePath } from \"@babel/core\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport createDecoratorTransform from \"./decorators.ts\";\nimport type { DecoratorVersionKind } from \"./decorators.ts\";\n\nimport semver from \"semver\";\n\nimport {\n  buildPrivateNamesNodes,\n  buildPrivateNamesMap,\n  transformPrivateNamesUsage,\n  buildFieldsInitNodes,\n  buildCheckInRHS,\n} from \"./fields.ts\";\nimport type { PropPath } from \"./fields.ts\";\nimport { buildDecoratedClass, hasDecorators } from \"./decorators-2018-09.ts\";\nimport { injectInitialization, extractComputedKeys } from \"./misc.ts\";\nimport {\n  enableFeature,\n  FEATURES,\n  isLoose,\n  shouldTransform,\n} from \"./features.ts\";\nimport { assertFieldTransformed } from \"./typescript.ts\";\n\nexport { FEATURES, enableFeature, injectInitialization, buildCheckInRHS };\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\ninterface Options {\n  name: string;\n  feature: number;\n  loose?: boolean;\n  inherits?: PluginObject[\"inherits\"];\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n  api?: PluginAPI;\n  decoratorVersion?: DecoratorVersionKind | \"2018-09\";\n}\n\nexport function createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api,\n  inherits,\n  decoratorVersion,\n}: Options): PluginObject {\n  if (feature & FEATURES.decorators) {\n    if (process.env.BABEL_8_BREAKING) {\n      return createDecoratorTransform(api, { loose }, \"2023-11\", inherits);\n    } else {\n      if (\n        decoratorVersion === \"2023-11\" ||\n        decoratorVersion === \"2023-05\" ||\n        decoratorVersion === \"2023-01\" ||\n        decoratorVersion === \"2022-03\" ||\n        decoratorVersion === \"2021-12\"\n      ) {\n        return createDecoratorTransform(\n          api,\n          { loose },\n          decoratorVersion,\n          inherits,\n        );\n      }\n    }\n  }\n  if (!process.env.BABEL_8_BREAKING) {\n    api ??= { assumption: () => void 0 as any } as any;\n  }\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const noUninitializedPrivateFieldAccess =\n    api.assumption(\"noUninitializedPrivateFieldAccess\") ?? false;\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(\n      `Cannot enable both the \"privateFieldsAsProperties\" and ` +\n        `\"privateFieldsAsSymbols\" assumptions as the same time.`,\n    );\n  }\n  const privateFieldsAsSymbolsOrProperties =\n    privateFieldsAsProperties || privateFieldsAsSymbols;\n\n  if (loose === true) {\n    type AssumptionName = Parameters<PluginAPI[\"assumption\"]>[0];\n    const explicit: `\"${AssumptionName}\"`[] = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(\n        `[${name}]: You are using the \"loose: true\" option and you are` +\n          ` explicitly setting a value for the ${explicit.join(\" and \")}` +\n          ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` +\n          ` can cause incompatibilities with the other class features` +\n          ` plugins, so it's recommended that you replace it with the` +\n          ` following top-level option:\\n` +\n          `\\t\"assumptions\": {\\n` +\n          `\\t\\t\"setPublicClassFields\": true,\\n` +\n          `\\t\\t\"privateFieldsAsSymbols\": true\\n` +\n          `\\t}`,\n      );\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      enableFeature(file, feature, loose);\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // Until 7.21.4, we used to encode the version as a number.\n        // If file.get(versionKey) is a number, it has thus been\n        // set by an older version of this plugin.\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, PACKAGE_JSON.version);\n          return;\n        }\n      }\n      if (\n        !file.get(versionKey) ||\n        semver.lt(file.get(versionKey), PACKAGE_JSON.version)\n      ) {\n        file.set(versionKey, PACKAGE_JSON.version);\n      }\n    },\n\n    visitor: {\n      Class(path, { file }) {\n        if (file.get(versionKey) !== PACKAGE_JSON.version) return;\n\n        if (!shouldTransform(path, file)) return;\n\n        const pathIsClassDeclaration = path.isClassDeclaration();\n\n        if (pathIsClassDeclaration) assertFieldTransformed(path);\n\n        const loose = isLoose(file, feature);\n\n        let constructor: NodePath<t.ClassMethod>;\n        const isDecorated = hasDecorators(path.node);\n        const props: PropPath[] = [];\n        const elements = [];\n        const computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[] = [];\n        const privateNames = new Set<string>();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if (\n            // check path.node.computed is enough, but ts will complain\n            (path.isClassProperty() || path.isClassMethod()) &&\n            path.node.computed