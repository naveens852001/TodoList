{"version":3,"names":["_checkInRHS","require","_setFunctionName","_toPropertyKey","applyDecs2311","targetClass","classDecs","memberDecs","classDecsHaveThis","instanceBrand","parentClass","symbolMetadata","Symbol","metadata","for","defineProperty","Object","create","existingNonFields","hasClassDecs","length","_","createRunInitializers","initializers","useStaticThis","hasValue","thisArg","value","i","apply","assertCallable","fn","hint1","hint2","throwUndefined","TypeError","applyDec","Class","decInfo","decoratorsHaveThis","name","kind","ret","isStatic","isPrivate","isField","hasPrivateBrand","assertInstanceIfPrivate","target","decs","concat","decVal","isClass","isAccessor","isGetter","isSetter","isMethod","_bindPropCall","before","_this","desc","call","init","key","get","setFunctionName","set","getOwnPropertyDescriptor","Error","newValue","dec","decThis","decoratorFinishedRef","ctx","addInitializer","initializer","v","push","bind","static","private","access","has","unshift","splice","applyMemberDecs","protoInitializers","staticInitializers","pushInitializers","applyMemberDecsOfKind","kindOnly","prototype","toPropertyKey","checkInRHS","defineMetadata","configurable","enumerable","undefined","e","c"],"sources":["../../src/helpers/applyDecs2311.ts"],"sourcesContent":["/* @minVersion 7.24.0 */\n/* @mangleFns */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion -- `typescript-eslint` complains when using `!` */\n\nimport checkInRHS from \"./checkInRHS.ts\";\nimport setFunctionName from \"./setFunctionName.ts\";\nimport toPropertyKey from \"./toPropertyKey.ts\";\n\nconst enum PROP_KIND {\n  FIELD = 0,\n  ACCESSOR = 1,\n  METHOD = 2,\n  GETTER = 3,\n  SETTER = 4,\n  CLASS = 5,\n  KIND_MASK = 7, // 0b111\n\n  STATIC = 8,\n\n  DECORATORS_HAVE_THIS = 16,\n}\n\ntype DecoratorFinishedRef = { v?: number };\ntype DecoratorContextAccess = {\n  get?: (target: object) => any;\n  set?: (target: object, value: any) => void;\n  has: (target: object) => boolean;\n};\ntype DecoratorContext = {\n  kind: \"accessor\" | \"method\" | \"getter\" | \"setter\" | \"field\" | \"class\";\n  name: string | symbol;\n  static?: boolean;\n  private?: boolean;\n  access?: DecoratorContextAccess;\n  metadata?: any;\n  addInitializer?: (initializer: Function) => void;\n};\ntype DecoratorInfo =\n  | [\n      decs: Function | Function[],\n      kind: PROP_KIND,\n      name: string,\n      privateGetter?: Function,\n      privateSetter?: Function,\n    ]\n  | [classDecs: Function[]];\ntype DecoratorNonFieldCheckStorage = Record<\n  string | symbol,\n  PROP_KIND.ACCESSOR | PROP_KIND.GETTER | PROP_KIND.SETTER\n>;\n/**\n  Basic usage:\n\n  applyDecs(\n    Class,\n    [\n      // member decorators\n      [\n        decs,               // dec, or array of decs, or array of this values and decs\n        0,                  // kind of value being decorated\n        'prop',             // name of public prop on class containing the value being decorated,\n        '#p',               // the name of the private property (if is private, void 0 otherwise),\n      ]\n    ],\n    [\n      // class decorators\n      dec1, dec2\n    ]\n  )\n  ```\n\n  Fully transpiled example:\n\n  ```js\n  @dec\n  class Class {\n    @dec\n    a = 123;\n\n    @dec\n    #a = 123;\n\n    @dec\n    @dec2\n    accessor b = 123;\n\n    @dec\n    accessor #b = 123;\n\n    @dec\n    c() { console.log('c'); }\n\n    @dec\n    #c() { console.log('privC'); }\n\n    @dec\n    get d() { console.log('d'); }\n\n    @dec\n    get #d() { console.log('privD'); }\n\n    @dec\n    set e(v) { console.log('e'); }\n\n    @dec\n    set #e(v) { console.log('privE'); }\n  }\n\n\n  // becomes\n  let initializeInstance;\n  let initializeClass;\n\n  let initA;\n  let initPrivA;\n\n  let initB;\n  let initPrivB, getPrivB, setPrivB;\n\n  let privC;\n  let privD;\n  let privE;\n\n  let Class;\n  class _Class {\n    static {\n      let ret = applyDecs(\n        this,\n        [\n          [dec, 0, 'a'],\n          [dec, 0, 'a', (i) => i.#a, (i, v) => i.#a = v],\n          [[dec, dec2], 1, 'b'],\n          [dec, 1, 'b', (i) => i.#privBData, (i, v) => i.#privBData = v],\n          [dec, 2, 'c'],\n          [dec, 2, 'c', () => console.log('privC')],\n          [dec, 3, 'd'],\n          [dec, 3, 'd', () => console.log('privD')],\n          [dec, 4, 'e'],\n          [dec, 4, 'e', () => console.log('privE')],\n        ],\n        [\n          dec\n        ]\n      );\n\n      initA = ret[0];\n\n      initPrivA = ret[1];\n\n      initB = ret[2];\n\n      initPrivB = ret[3];\n      getPrivB = ret[4];\n      setPrivB = ret[5];\n\n      privC = ret[6];\n\n      privD = ret[7];\n\n      privE = ret[8];\n\n      initializeInstance = ret[9];\n\n      Class = ret[10]\n\n      initializeClass = ret[11];\n    }\n\n    a = (initializeInstance(this), initA(this, 123));\n\n    #a = initPrivA(this, 123);\n\n    #bData = initB(this, 123);\n    get b() { return this.#bData }\n    set b(v) { this.#bData = v }\n\n    #privBData = initPrivB(this, 123);\n    get #b() { return getPrivB(this); }\n    set #b(v) { setPrivB(this, v); }\n\n    c() { console.log('c'); }\n\n    #c(...args) { return privC(this, ...args) }\n\n    get d() { console.log('d'); }\n\n    get #d() { return privD(this); }\n\n    set e(v) { console.log('e'); }\n\n    set #e(v) { privE(this, v); }\n  }\n\n  initializeClass(Class);\n */\n\nexport default /* @no-mangle */ function applyDecs2311(\n  targetClass: any,\n  classDecs: Function[],\n  memberDecs: DecoratorInfo[],\n  classDecsHaveThis: number,\n  instanceBrand: Function,\n  parentClass: any,\n) {\n  var symbolMetadata = Symbol.metadata || Symbol.for(\"Symbol.metadata\");\n  var defineProperty = Object.defineProperty;\n  var create = Object.create;\n  var metadata: any;\n  // Use both as and satisfies to ensure that we only use non-zero values\n  var existingNonFields = [create(null), create(null)] as [\n    DecoratorNonFieldCheckStorage,\n    DecoratorNonFieldCheckStorage,\n  ];\n  var hasClassDecs = classDecs.length;\n  // This is a temporary variable for smaller helper size\n  var _: any;\n\n  function createRunInitializers(\n    initializers: Function[],\n    useStaticThis?: 0 | 1 | boolean,\n    hasValue?: 0 | 1,\n  ) {\n    return function (thisArg: any, value?: any) {\n      if (useStaticThis) {\n        value = thisArg;\n        thisArg = targetClass;\n      }\n      for (var i = 0; i < initializers.length; i++) {\n        value = initializers[i].apply(thisArg, hasValue ? [value] : []);\n      }\n      return hasValue ? value : thisArg;\n    };\n  }\n\n  function assertCallable(\n    fn: any,\n    hint1: string,\n    hint2?: string,\n    throwUndefined?: boolean,\n  ) {\n    if (typeof fn !== \"function\") {\n      if (throwUndefined || fn !== void 0) {\n        throw new TypeError(\n          hint1 +\n            \" must \" +\n            (hint2 || \"be\") +\n            \" a function\" +\n            (throwUndefined ? \"\" : \" or undefined\"),\n        );\n      }\n    }\n    return fn;\n  }\n\n  /* @no-mangle */\n  function applyDec(\n    Class: any,\n    decInfo: DecoratorInfo,\n    decoratorsHaveThis: 0 | PROP_KIND.DECORATORS_HAVE_THIS,\n    name: string | symbol,\n    kind: PROP_KIND,\n    initializers: Function[],\n    ret?: Function[],\n    isStatic?: boolean,\n    isPrivate?: boolean,\n    isField?: 0 | 1,\n    hasPrivateBrand?: Function,\n  ) {\n    function assertInstanceIfPrivate(target: any) {\n      if (!hasPrivateBrand!(target)) {\n        throw new TypeError(\n          \"Attempted to access private element on non-instance\",\n        );\n      }\n    }\n\n    var decs = ([] as Function[]).concat(decInfo[0]),\n      decVal = decInfo[3],\n      isClass = !ret;\n\n    var isAccessor = kind === PROP_KIND.ACCESSOR;\n    var isGetter = kind === PROP_KIND.GETTER;\n    var isSetter = kind === PROP_KIND.SETTER;\n    var isMethod = kind === PROP_KIND.METHOD;\n\n    function _bindPropCall(\n      name: keyof PropertyDescriptor,\n      useStaticThis: 0 | 1 | boolean,\n      before?: Function,\n    ) {\n      return function (_this: any, value?: any) {\n        if (useStaticThis) {\n          value = _this;\n          _this = Class;\n        }\n        if (before) {\n          before(_this);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return desc[name].call(_this, value);\n      };\n    }\n\n    if (!isClass) {\n      var desc: PropertyDescriptor = {},\n        init: Function[] = [],\n        key: \"get\" | \"set\" | \"value\" = isGetter\n          ? \"get\"\n          : isSetter || isAccessor\n            ? \"set\"\n            : \"value\";\n\n      if (isPrivate) {\n        if (isField || isAccessor) {\n          desc = {\n            get: setFunctionName(\n              function (this: any) {\n                return decVal!(this);\n              },\n              name,\n              \"get\",\n            ),\n            set: function (this: any, value: any) {\n              decInfo[4]!(this, value);\n            },\n          };\n        } else {\n          desc[key] = decVal;\n        }\n\n        if (!isField) {\n          setFunctionName(desc[key], name, isMethod ? \"\" : key);\n        }\n      } else if (!isField) {\n        desc = Object.getOwnPropertyDescriptor(Class, name)!;\n      }\n\n      if (!isField && !isPrivate) {\n        _ = existingNonFields[+isStatic!][name];\n        // flag is 1, 3, or 4; kind is 0, 1, 2, 3, or 4\n        // flag ^ kind is 7 if and only if one of them is 3 and the other one is 4.\n        if (_ && (_ ^ kind) !== 7) {\n          throw new Error(\n            \"Decorating two elements with the same name (\" +\n              desc[key].name +\n              \") is not supported yet\",\n          );\n        }\n        // We use PROP_KIND.ACCESSOR to mark a name as \"fully used\":\n        // either a get/set pair, or a non-getter/setter.\n        existingNonFields[+isStatic!][name] =\n          kind < PROP_KIND.GETTER\n            ? PROP_KIND.ACCESSOR\n            : (kind as PROP_KIND.GETTER | PROP_KIND.SETTER);\n      }\n    }\n\n    var newValue = Class;\n\n    for (var i = decs.length - 1; i >= 0; i -= decoratorsHaveThis ? 2 : 1) {\n      var dec = assertCallable(decs[i], \"A decorator\", \"be\", true) as Function,\n        decThis = decoratorsHaveThis ? decs[i - 1] : void 0;\n\n      var decoratorFinishedRef: DecoratorFinishedRef = {};\n      var ctx: DecoratorContext = {\n        kind: [\"field\", \"accessor\", \"method\", \"getter\", \"setter\", \"class\"][\n          kind\n        ] as any,\n\n        name: name,\n        metadata: metadata,\n        addInitializer: function (\n          decoratorFinishedRef: DecoratorFinishedRef,\n          initializer: Function,\n        ) {\n          if (decoratorFinishedRef.v) {\n            throw new TypeError(\n              \"attempted to call addInitializer after decoration was finished\",\n            );\n          }\n          assertCallable(initializer, \"An initializer\", \"be\", true);\n          initializers.push(initializer);\n        }.bind(null, decoratorFinishedRef),\n      };\n\n      if (isClass) {\n        _ = dec.call(decThis, newValue, ctx);\n        decoratorFinishedRef.v = 1;\n\n        if (assertCallable(_, \"class decorators\", \"return\")) {\n          newValue = _;\n        }\n      } else {\n        ctx.static = isStatic;\n        ctx.private = isPrivate;\n\n        _ = ctx.access = {\n          has: isPrivate\n            ? // @ts-expect-error no thisArg\n              hasPrivateBrand.bind()\n            : function (target: object) {\n                return name in target;\n              },\n        };\n\n        if (!isSetter) {\n          _.get = isPrivate\n            ? isMethod\n              ? function (_this: any) {\n                  assertInstanceIfPrivate(_this);\n                  return desc.value;\n                }\n              : _bindPropCall(\"get\", 0, assertInstanceIfPrivate)\n            : function (target: any) {\n                return target[name];\n              };\n        }\n        if (!isMethod && !isGetter) {\n          _.set = isPrivate\n            ? _bindPropCall(\"set\", 0, assertInstanceIfPrivate)\n            : function (target: any, v: any) {\n                target[name] = v;\n              };\n        }\n\n        newValue = dec.call(\n          decThis,\n          isAccessor\n            ? {\n                get: desc!.get,\n                set: desc!.set,\n              }\n            : desc![key!],\n          ctx,\n        );\n        decoratorFinishedRef.v = 1;\n\n        if (isAccessor) {\n          if (typeof newValue === \"object\" && newValue) {\n            if ((_ = assertCallable(newValue.get, \"accessor.get\"))) {\n              desc!.get = _;\n            }\n            if ((_ = assertCallable(newValue.set, \"accessor.set\"))) {\n              desc!.set = _;\n            }\n            if ((_ = assertCallable(newValue.init, \"accessor.init\"))) {\n              init!.unshift(_);\n            }\n          } else if (newValue !== void 0) {\n            throw new TypeError(\n              \"accessor decorators must return an object with get, set, or init properties or undefined\",\n            );\n          }\n        } else if (\n          assertCallable(\n            newValue,\n            (isField ? \"field\" : \"method\") + \" decorators\",\n            \"return\",\n          )\n        ) {\n          if (isField) {\n            init!.unshift(newValue);\n          } else {\n            desc![key!] = newValue;\n          }\n        }\n      }\n    }\n\n    // isField || isAccessor\n    if (kind < PROP_KIND.METHOD) {\n      ret!.push(\n        // init\n        createRunInitializers(init!, isStatic, 1),\n        // init_extra\n        createRunInitializers(initializers, isStatic, 0),\n      );\n    }\n\n    if (!isField && !isClass) {\n      if (isPrivate) {\n        if (isAccessor) {\n          // get and set should be returned before init_extra\n          ret!.splice(\n            -1,\n            0,\n            _bindPropCall(\"get\", isStatic!),\n            _bindPropCall(\"set\", isStatic!),\n          );\n        } else {\n          ret!.push(\n            isMethod\n              ? desc![key!]\n              : // Equivalent to `Function.call`, just to reduce code size\n                assertCallable.call.bind(desc![key!]),\n          );\n        }\n      } else {\n        defineProperty(Class, name, desc!);\n      }\n    }\n    return newValue;\n  }\n\n  /* @no-mangle */\n  function applyMemberDecs() {\n    var ret: Function[] = [];\n    var protoInitializers: Function[];\n    var staticInitializers: Function[];\n\n    var pushInitializers = function (initializers: Function[]) {\n      if (initializers) {\n        ret.push(createRunInitializers(initializers));\n      }\n    };\n\n    var applyMemberDecsOfKind = function (\n      isStatic: PROP_KIND.STATIC | 0,\n      isField: 0 | 1,\n    ) {\n      for (var i = 0; i < memberDecs.length; i++) {\n        var decInfo = memberDecs[i];\n\n        var kind = decInfo[1]!;\n        var kindOnly: PROP_KIND = kind & PROP_KIND.KIND_MASK;\n        if (\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison, eqeqeq\n          (kind & PROP_KIND.STATIC) == isStatic &&\n          // @ts-expect-error comparing a boolean with 0 | 1\n          // eslint-disable-next-line eqeqeq\n          !kindOnly == isField\n        ) {\n          var name = decInfo[2];\n          var isPrivate = !!decInfo[3];\n\n          var decoratorsHaveThis: 0 | PROP_KIND.DECORATORS_HAVE_THIS =\n            kind & PROP_KIND.DECORATORS_HAVE_THIS;\n\n          applyDec(\n            isStatic ? targetClass : targetClass.prototype,\n            decInfo,\n            decoratorsHaveThis,\n            isPrivate ? \"#\" + name : (toPropertyKey(name) as string),\n            kindOnly,\n            kindOnly < PROP_KIND.METHOD // isField || isAccessor\n              ? /* fieldInitializers */ []\n              : isStatic\n                ? (staticInitializers = staticInitializers || [])\n                : (protoInitializers = protoInitializers || []),\n            ret,\n            !!isStatic,\n            isPrivate,\n            isField,\n            isStatic && isPrivate\n              ? function (_: any) {\n                  return checkInRHS(_) === targetClass;\n                }\n              : instanceBrand,\n          );\n        }\n      }\n    };\n\n    applyMemberDecsOfKind(PROP_KIND.STATIC, 0);\n    applyMemberDecsOfKind(0, 0);\n    applyMemberDecsOfKind(PROP_KIND.STATIC, 1);\n    applyMemberDecsOfKind(0, 1);\n\n    pushInitializers(protoInitializers!);\n    pushInitializers(staticInitializers!);\n    return ret;\n  }\n\n  function defineMetadata(Class: any) {\n    return defineProperty(Class, symbolM